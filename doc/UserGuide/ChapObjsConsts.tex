\chapter{Objects and Constants}
\label{Chp:Objects}

In this chapter, all of the enumerations, literals, data types, and predefined 
opaque objects defined in the GraphBLAS API are presented.  Enumeration literals 
in GraphBLAS are assigned specific values to ensure compatibility between 
different runtime library implementations.  The chapter starts by defining the
enumerations that are used by the {\sf init()} and {\sf wait()} methods.  Then
a number of transparent (i.e., non-opaque) types that are used for interfacing 
with external data are defined.  Sections that follow describe the various
types of opaque objects in GraphBLAS: types (or \emph{domains}), algebraic 
objects, collections and descriptors.  Each of these sections also lists the 
predefined instances of each opaque type that are required by the API.  This chapter
concludes with a section on the definition for {\sf GrB\_Info} enumeration 
that is used as the return type of all methods.

%============================================================================
\section{Enumerations for {\sf init()} and {\sf wait()}}

Table~\ref{Tab:EnumerationModes} lists the enumerations and the corresponding
values used in the {\sf GrB\_init()} method to set the execution mode and in
the {\sf GrB\_wait()} method for completing or materializing opaque objects.

%============================================================================
\section{Indices, index arrays, and scalar arrays}

In order to interface with third-party software (\ie, software other than
an implementation of the GraphBLAS), operations 
such as {\sf GrB\_Matrix\_build} (Section~\ref{Sec:Matrix_build}) and
{\sf GrB\_Matrix\_extractTuples} (Section~\ref{Sec:Matrix_extractTuples}) must specify
how the data should be laid out in  non-opaque data structures.  To 
this end we explicitly define the types for indices and the arrays 
used by these operations.

For indices a {\sf typedef} is used to give a GraphBLAS name to a concrete type. We define it as follows:
\begin{verbatim}
    typedef uint64_t GrB_Index;
\end{verbatim}
The range of valid values for a variable of type {\sf GrB\_Index} is [0, {\sf GrB\_INDEX\_MAX}] 
where the largest index value permissible is defined with a macro, {\sf GrB\_INDEX\_MAX}. For example:
\begin{verbatim}
    #define GrB_INDEX_MAX ((GrB_Index) 0x0fffffffffffffff);
\end{verbatim}
An implementation is required to define and document this value.

An index array is a pointer to a set of {\sf GrB\_Index} values that are 
stored in a contiguous block of memory (\ie, {\sf GrB\_Index*}).
Likewise, a scalar array is a pointer to a contiguous block of memory 
storing a number of scalar values as specified by the user.
Some GraphBLAS operations (\eg, {\sf GrB\_assign})  include an input parameter with the type of an index array. 
This input index array selects a subset of elements from a GraphBLAS vector or matrix object to be used in the operation.
In these cases, the literal {\sf GrB\_ALL} 
can be used in place of the index array input parameter to indicate that all indices 
of the associated GraphBLAS vector or matrix object should be used.
%As with any literal defined in the GraphBLAS, 
An implementation of the GraphBLAS C API has considerable 
freedom in terms of how {\sf GrB\_ALL} is defined.  Since {\sf GrB\_ALL} is used as an argument for an array 
parameter, it must use a type consistent with a pointer. {\sf GrB\_ALL} must also have a non-null
value to distinguish it from the erroneous case of passing a {\sf NULL} pointer as an array.

\begin{table}[b!]
\hrule
\begin{center}
\caption{Enumeration literals and corresponding values input to various GraphBLAS methods.}
\label{Tab:EnumerationModes}

\vspace{1\baselineskip}
(a) {\sf GrB\_Mode} execution modes for the {\sf GrB\_init} method.
\vspace{1\baselineskip}

\begin{tabular}{l|r|p{4in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_NONBLOCKING}   &  0 & Specifies the nonblocking mode context.\\
{\sf GrB\_BLOCKING}      &  1 & Specifies the blocking mode context. \\
\end{tabular}

\vspace{2\baselineskip}
(b) {\sf GrB\_WaitMode} wait modes for the {\sf GrB\_wait} method.
\vspace{1\baselineskip}

\begin{tabular}{l|r|p{4in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_COMPLETE}    &  0 & The object is in a state where it can be used in a happens-before relation so that multithreaded programs can be properly synchronized.\\
{\sf GrB\_MATERIALIZE} &  1 & The object is \emph{complete}, and in addition, all computation of the object is finished and any error information is available. \\
\end{tabular}

\end{center}
\hrule
\end{table}

%============================================================================
\section{Types (domains)}
\label{Sec:Domains}

In GraphBLAS, domains correspond to the valid values for types from the
host language (in our case, the C programming language).  GraphBLAS defines
a number of operators that take elements from one or more domains and produce elements of a (possibly) different domain.  GraphBLAS also defines 
three kinds of collections: matrices, vectors and scalars.  For any given 
collection, the elements of the collection belong to a \emph{domain}, which 
is the set of valid values for the elements.  For any variable 
or object $V$ in GraphBLAS we denote as $\mathbf{D}(V)$ the domain of $V$,
that is, the set of possible values that elements of $V$ can take.  

The domains for elements that can be stored in collections and operated on
through GraphBLAS methods are defined by GraphBLAS objects called {\sf GrB\_Type}.
The predefined types and corresponding domains used in the GraphBLAS C API are
shown in Table~\ref{Tab:PredefinedTypes}.  The Boolean type ({\tt bool})
is defined in {\tt stdbool.h}, the integral types ({\tt int8\_t},
{\tt uint8\_t}, {\tt int16\_t}, {\tt uint16\_t}, {\tt int32\_t},
{\tt uint32\_t}, {\tt int64\_t}, {\tt uint64\_t}) are defined in {\tt
stdint.h}, and the floating-point types ({\tt float}, {\tt double}) are
native to the language and platform and in most cases defined by the 
IEEE-754 standard.

\begin{table}
\hrule
\begin{center}
\caption[Predefined {\sf GrB\_Type} values.]{Predefined {\sf GrB\_Type} values, and the corresponding GraphBLAS domain 
suffixes, C type (for scalar parameters), and domains for GraphBLAS.  The domain
suffixes are used in place of $I$, $F$, and $T$ in 
Tables~\ref{Tab:PredefOperators}, \ref{Tab:PredefIndexOperators}, 
\ref{Tab:PredefinedMonoids}, \ref{Tab:PredefinedTrueSemirings}, 
and~\ref{Tab:PredefinedUsefulSemirings}).}
\label{Tab:PredefinedTypes}
\label{Tab:PredefinedDomains}

\vspace{1\baselineskip}
\begin{tabular}{l|l|l|l}
{\sf GrB\_Type}   & Suffix       & C type          & Domain \\
\hline
{\sf GrB\_BOOL}   & {\sf BOOL}   & {\tt bool}      & $\{ {\tt false}, {\tt true} \}$  \\
{\sf GrB\_INT8}   & {\sf INT8}   & {\tt int8\_t}   & $\mathbb{Z} \cap [-2^{7},2^{7})$  \\
{\sf GrB\_UINT8}  & {\sf UINT8}  & {\tt uint8\_t}  & $\mathbb{Z} \cap [0,2{^8})$  \\
{\sf GrB\_INT16}  & {\sf INT16}  & {\tt int16\_t}  & $\mathbb{Z} \cap [-2^{15},2^{15})$ \\
{\sf GrB\_UINT16} & {\sf UINT16} & {\tt uint16\_t} & $\mathbb{Z} \cap [0,2^{16})$ \\
{\sf GrB\_INT32}  & {\sf INT32}  & {\tt int32\_t}  & $\mathbb{Z} \cap [-2^{31},2^{31})$ \\
{\sf GrB\_UINT32} & {\sf UINT32} & {\tt uint32\_t} & $\mathbb{Z} \cap [0,2^{32})$ \\
{\sf GrB\_INT64}  & {\sf INT64}  & {\tt int64\_t}  & $\mathbb{Z} \cap [-2^{63},2^{63})$ \\
{\sf GrB\_UINT64} & {\sf UINT64} & {\tt uint64\_t} & $\mathbb{Z} \cap [0,2^{64})$ \\
{\sf GrB\_FP32}   & {\sf FP32}   & {\tt float}     & IEEE 754 {\sf binary32}  \\
{\sf GrB\_FP64}   & {\sf FP64}   & {\tt double}    & IEEE 754 {\sf binary64}  
\end{tabular}
\end{center}
\hrule
\end{table}

%============================================================================
\section{Collections}

%----------------------------------------------------------------------------
\subsection{Scalars}
\label{Sec:Scalars}

A \emph{GraphBLAS scalar}, $\scalar{s} = \langle D, \{ \sigma \} \rangle$, is defined by
a domain $D$, and a set of zero or one \emph{scalar value}, $\sigma$, where $\sigma \in D$. 
We define $\mathbf{size}(\scalar{s}) = 1$ (constant), and
$\mathbf{L}(\scalar{s}) = \{ \sigma \}$. The set $\mathbf{L}(\scalar{s})$ is
called the \emph{contents} of the GraphBLAS scalar $\scalar{s}$. We also define 
$\mathbf{D}(\scalar{s}) = D$. Finally, $\mathbf{val}(s)$ is a 
reference to the scalar value, $\sigma$, if the GraphBLAS scalar is not empty, and is 
undefined otherwise.

%----------------------------------------------------------------------------
\subsection{Vectors}
\label{Sec:Vectors}

A vector $\vector{v} = \langle D, N, \{ (i,v_i) \} \rangle$ is defined by
a domain $D$, a size $N>0$, and a set of tuples $(i,v_i)$ where $0 \leq
i < N$ and $v_i \in D$. A particular value of $i$ can appear at
most once in $\vector{v}$. We define $\mathbf{size}(\vector{v}) = N$ and
$\mathbf{L}(\vector{v}) = \{ (i,v_i) \}$. The set $\mathbf{L}(\vector{v})$ is
called the \emph{content} of vector $\vector{v}$. We also define the set
$\vector{ind(\vector{v})} = \{ i : (i,v_i) \in \mathbf{L}(\vector{v}) \}$
(called the \emph{structure} of $\vector{v}$), and $\mathbf{D}(\vector{v})
= D$. For a vector $\vector{v}$, $\vector{v}(i)$ is a reference to $v_i$
if $(i,v_i) \in \mathbf{L}(\vector{v})$ and is undefined otherwise.

%----------------------------------------------------------------------------
\subsection{Matrices}
\label{Sec:Matrices}

A matrix $\matrix{A} = \langle D, M, N, \{ (i,j,A_{ij}) \} \rangle$ is
defined by a domain $D$, its number of rows $M>0$, its number of columns
$N>0$, and a set of tuples $(i,j,A_{ij})$ where $0 \leq i < M$, $0 \leq
j < N$, and $A_{ij} \in D$. A particular pair of values $i,j$ can
appear at most once in $\matrix{A}$. We define $\mathbf{ncols}(\matrix{A})
= N$,  $\mathbf{nrows}(\matrix{A}) = M$, and $\mathbf{L}(\matrix{A}) =
\{ (i,j,A_{ij}) \}$.  The set $\mathbf{L}(\matrix{A})$ is called the
\emph{content} of matrix $\matrix{A}$.  We also define the sets
$\vector{indrow(\matrix{A})} = \{ i : \exists (i,j,A_{ij}) \in
\matrix{A} \}$ and $\vector{indcol(\matrix{A})} = \{ j : \exists
(i,j,A_{ij}) \in \matrix{A} \}$.  (These are the sets of nonempty
rows and columns of $\matrix{A}$, respectively.)  The \emph{structure}
of matrix $\matrix{A}$ is the set $\mathbf{ind}(\matrix{A}) = \{ (i,j) :
(i,j,A_{ij}) \in \mathbf{L}(\matrix{A}) \}$, and $\mathbf{D}(\matrix{A}) = D$.
For a matrix $\matrix{A}$, $\matrix{A}(i,j)$ is a reference to $A_{ij}$
if $(i,j,A_{ij}) \in \mathbf{L}(\matrix{A})$ and is undefined otherwise.

If $\matrix{A}$ is a matrix and $0 \leq j < N$, then $\matrix{A}(:,j)
= \langle D, M, \{(i,A_{ij}) : (i,j,A_{ij}) \in \mathbf{L}(\matrix{A})
\} \rangle$ is a vector called the $j$-th \emph{column}
of $\matrix{A}$. Correspondingly, if $\matrix{A}$ is a matrix and
$0 \leq i < M$, then $\matrix{A}(i,:) = \langle D, N, \{(j,A_{ij}) :
(i,j,A_{ij}) \in \mathbf{L}(\matrix{A}) \} \rangle$ is a vector called
the $i$-th \emph{row} of $\matrix{A}$.

Given a matrix $\matrix{A} = \langle D, M, N, \{ (i,j,A_{ij}) \} \rangle$,
its \emph{transpose} is another matrix $\matrix{A}^T = \langle D, N, M, \{
(j,i,A_{ij}) : (i,j,A_{ij}) \in \mathbf{L}(\matrix{A}) \} \rangle$.

%----------------------------------------------------------------------------
\subsubsection{External matrix formats}\label{Sec:GrB_Format}

The specification also supports the export and import of matrices to/from a 
number of commonly used formats, such as COO, CSR, and CSC formats.  When
importing or exporting a matrix to or from a GraphBLAS object using
{\sf GrB\_Matrix\_import} (\S~\ref{Sec:Matrix_import}) or {\sf GrB\_Matrix\_export} (\S~\ref{Sec:Matrix_export}), it is necessary to
specify the data format for the matrix data external to GraphBLAS, which is
being imported from or exported to.  This non-opaque data format is specified
using an argument of enumeration type {\sf GrB\_Format} that is used to 
indicate one of a number of predefined formats.  The predefined values of 
{\sf GrB\_Format} are specified in Table~\ref{Tab:MatrixFormatEnumerationValues}.  
A precise definition of the non-opaque data formats can be found in 
Appendix~\ref{App:Matrix_format_details}.

\begin{table}[bh]
\hrule
\begin{center}
\caption{{\sf GrB\_Format} enumeration literals and corresponding values for 
matrix import and export methods.}
\label{Tab:MatrixFormatEnumerationValues}

\begin{tabular}{l|r|p{3.75in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_CSR\_FORMAT} & 0 & Specifies the compressed sparse row matrix format.\\
{\sf GrB\_CSC\_FORMAT} & 1 & Specifies the compressed sparse column matrix format.\\
{\sf GrB\_COO\_FORMAT} & 2 & Specifies the sparse coordinate matrix format.\\
% {\sf GrB\_DENSE\_ROW\_FORMAT} & 3 & Specifies the dense row-major matrix format.\\
% {\sf GrB\_DENSE\_COL\_FORMAT} & 4 & Specifies the dense column-major matrix format.\\
\end{tabular}

\end{center}
\hrule
\end{table}


%============================================================================
\section{{GrB\_Info} return values}

All GraphBLAS methods return a {\sf GrB\_Info} enumeration value. The three
types of return codes (informational, API error, and execution error) and their
corresponding values are listed in Table~\ref{Tab:GrBInfoValues}.

\begin{table}[bh]
\hrule
\begin{center}
\caption{Enumeration literals and corresponding values returned by GraphBLAS methods and operations.}
\label{Tab:GrBInfoValues}

\vspace{1\baselineskip}
(a) Informational return values
\vspace{1\baselineskip}

\begin{tabular}{l|r|p{4.45in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_SUCCESS}     &  0 & The method/operation completed successfully (blocking mode), or encountered no API errors (non-blocking mode). \\
{\sf GrB\_NO\_VALUE}   &  1 & A location in a matrix or vector is being accessed that has no stored value at the specified location.\\
\end{tabular}

\vspace{1\baselineskip}
(b) API errors
\vspace{1\baselineskip}

\begin{tabular}{l|r|p{3.45in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_UNINITIALIZED\_OBJECT} & -1 & A GraphBLAS object is passed to a method before {\sf new} was called on it.\\
{\sf GrB\_NULL\_POINTER}         & -2 & A NULL is passed for a pointer parameter. \\
{\sf GrB\_INVALID\_VALUE}        & -3 & Miscellaneous incorrect values. \\
{\sf GrB\_INVALID\_INDEX}        & -4 & Indices passed are larger than dimensions of the matrix or vector being accessed. \\
{\sf GrB\_DOMAIN\_MISMATCH}      & -5 & A mismatch between domains of collections and operations when user-defined domains are in use.\\
{\sf GrB\_DIMENSION\_MISMATCH}~~ & -6 & Operations on matrices and vectors with incompatible dimensions. \\
{\sf GrB\_OUTPUT\_NOT\_EMPTY}    & -7 & An attempt was made to build a matrix or vector using an output object that already contains valid tuples (elements).\\
{\sf GrB\_NOT\_IMPLEMENTED}      & -8 &  An attempt was made to call a GraphBLAS method for a combination of input parameters that is not supported by a particular implementation.\\
\end{tabular}

\vspace{1\baselineskip}
(c) Execution errors
\vspace{1\baselineskip}

\begin{tabular}{l|r|p{3.4in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_PANIC}                  & -101 & Unknown internal error. \\
{\sf GrB\_OUT\_OF\_MEMORY}        & -102 & Not enough memory for operations. \\
{\sf GrB\_INSUFFICIENT\_SPACE}    & -103 & The array provided is not large enough to hold output. \\
{\sf GrB\_INVALID\_OBJECT}        & -104 & One of the opaque GraphBLAS objects (input or output) is in an invalid state caused by a previous execution error. \\
{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS} & -105 & Reference to a vector or matrix element that is outside the defined dimensions of the object. \\
{\sf GrB\_EMPTY\_OBJECT}          & -106 & One of the opaque GraphBLAS objects does not have a stored value. \\
\end{tabular}

\end{center}
\hrule
\end{table}

