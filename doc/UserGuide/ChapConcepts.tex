\chapter{Basic concepts}
\label{Chp:Concepts}

The LAGraph library is a collection of high level graph algorithms
based on the GraphBLAS C API.  These algorithms construct  
graph algorithms expressed ``in the language of linear algebra.''
Graphs are expressed as matrices, and the operations over 
these matrices are generalized through the use of a
semiring algebraic structure.

In this chapter, we will define the basic concepts used to
define the LAGraph Library  We provide the following elements:

\begin{itemize}
\item Glossary of terms and notation used in this document.  
\item The LAGraph objects. 
\item Return codes and other constants used in LAGraph.
\end{itemize}

\section{Glossary}

%=============================================================================

\subsection{LAGraph basic definitions}

\glossBegin

\glossItem{application} A program that calls methods from LAGraph to
solve a problem.

\glossItem{GraphBLAS C API} The application programming interface that fully defines the types, objects, 
literals, and other elements of the C binding to the GraphBLAS.  LAGraph uses the GraphBLAS to
implement graph algorithms.

\glossItem{method} A function defined in the GraphBLAS C API that manipulates
GraphBLAS objects or other opaque features of the implementation of the GraphBLAS API.

\glossItem{operator} A function that performs an operation on the elements stored in GraphBLAS matrices and vectors.

\glossItem{GraphBLAS operation} A mathematical operation defined in the
GraphBLAS mathematical specification. These operations (not to be confused with \emph{operators}) typically act
on matrices and vectors with elements defined in terms of an algebraic semiring. 
\glossEnd

%=============================================================================

\subsection{LAGraph objects and their structure}

\glossBegin
\glossItem{non-opaque datatype} Any datatype that exposes its internal structure and
can be manipulated directly by the user.   

\glossItem{opaque datatype} Any datatype that hides its internal structure and can
be manipulated only through an API.

\glossItem{GraphBLAS object}  An instance of an \emph{opaque datatype} defined 
by the \emph{GraphBLAS C API} that is manipulated only through the GraphBLAS 
API. There are four kinds of GraphBLAS opaque objects: \emph{domains} (i.e., types), 
\emph{algebraic objects} (operators, monoids and semirings), 
\emph{collections} (scalars, vectors, matrices and masks), and descriptors.   

\glossItem{handle}  A variable that holds a reference to an instance of one of 
the GraphBLAS opaque objects.  The value of this variable holds a reference to 
a GraphBLAS object but not the contents of the object itself.  Hence, assigning 
a value to another variable copies the reference to the GraphBLAS object of one 
handle but not the contents of the object.

\glossItem{LAGraph object}  An instance of a \emph{datatype} defined 
by the \emph{LAGraph C API}.  LAGraph objects are not opaque.  They
often contain handles to GraphBLAS objects.     

\glossItem{domain} The set of valid values for the elements stored in a 
GraphBLAS \emph{collection} or operated on by a GraphBLAS \emph{operator}.
Note that some GraphBLAS objects involve functions that map values from 
one or more input domains onto values in an output domain.  These GraphBLAS 
objects would have multiple domains.
\glossEnd

%=============================================================================

\subsection{The execution of an application using the LAGraph C API}

\glossBegin
\glossItem{program order} The order of the GraphBLAS method calls in a
thread, as defined by the text of the program.

\glossItem{host programming environment} The GraphBLAS specification defines an API.  
The functions from the API appear in a program.  This program is written using a programming language
and execution environment defined outside of LAGraph.  We refer to this programming environment
as the ``host programming environment''.

\glossItem{context}  An instance of the LAGraph library implementation
as seen by an application.  An application can have only one context between the 
start and end of the application.  
\glossEnd

%=============================================================================

\subsection{GraphBLAS methods: behaviors and error conditions}
\glossBegin
\glossItem{implementation-defined behavior} Behavior that must be documented
by the implementation and is allowed to vary among different
compliant implementations. 

\glossItem{undefined behavior} Behavior that is not specified by the GraphBLAS C API.
A conforming implementation is free to choose results delivered from a method
whose behavior is undefined. 

\glossItem{thread-safe}  Consider a function called from multiple threads with 
arguments that do not overlap in memory (i.e. the argument lists do not share 
memory).  If the function is \emph{thread-safe} then it will behave the same 
when executed concurrently by multiple threads or sequentially on a single 
thread.

\glossItem{dimension compatible} GraphBLAS objects (matrices and vectors) that are
passed as parameters to a GraphBLAS method are dimension (or shape) compatible if
they have the correct number of dimensions and sizes for each dimension to satisfy 
the rules of the mathematical definition of the operation associated with the method. 
If any \emph{dimension compatibility} rule above is violated, execution of the GraphBLAS 
method ends and the {\sf GrB\_DIMENSION\_MISMATCH} error is returned.
\glossEnd


\section{Mathematical foundations}

Graphs can be represented in terms of matrices. The values stored in these 
matrices correspond to attributes (often weights) of edges in the graph.\footnote{More information on the mathematical foundations can be found in the following paper: J. Kepner, P. Aaltonen, D. Bader,  A. Bulu√ß, F. Franchetti, J. Gilbert, D. Hutchison, M. Kumar, A. Lumsdaine, H. Meyerhenke, S. McMillan, J. Moreira, J. Owens, C. Yang, M. Zalewski, and T. Mattson. 2016, September. Mathematical foundations of the GraphBLAS. In \emph{2016 IEEE High Performance Extreme Computing Conference (HPEC)} (pp. 1-9). IEEE.} 
Likewise, information about vertices in a graph are stored in vectors.
The set of valid values that can be stored in either matrices or vectors
is referred to as their domain. Matrices are usually sparse because the 
lack of an edge between two vertices means that nothing is stored at the 
corresponding location in the matrix.  Vectors may be sparse or dense, or they may 
start out sparse and become dense as algorithms traverse the graphs.

Operations defined by the GraphBLAS C API specification operate on these 
matrices and vectors to carry out graph algorithms.  These GraphBLAS 
operations are defined in terms of GraphBLAS semiring algebraic 
structures. Modifying the underlying semiring changes the result of 
an operation to support a wide range of graph algorithms.
Inside a given algorithm, it is often beneficial to change the GraphBLAS 
semiring that applies to an operation on a matrix.  This has two 
implications for the C binding of the GraphBLAS API.  

First, it means that we define a separate object for the semiring 
to pass into methods.  Since in many cases the full
semiring is not required, we also support passing monoids or
even binary operators, which means the semiring is implied rather than 
explicitly stated.

Second, the ability to change semirings impacts the meaning of 
the \emph{implied zero} in a sparse representation of a matrix or vector.
This element in real arithmetic is zero, which is the 
identity of the \emph{addition} operator and the annihilator of the
\emph{multiplication} operator.  As the semiring changes, this 
implied zero changes to the identity of the \emph{addition} operator 
and the annihilator (if present) of the \emph{multiplication} operator 
for the new semiring. Nothing changes regarding what is stored in the sparse 
matrix or vector, but the implied zeros within them change with respect to a 
particular operation. In all cases, the nature of the implied zero does not 
matter since the GraphBLAS C API requires that implementations treat them as 
nonexistent elements of the matrix or vector.

As with matrices and vectors, GraphBLAS semirings have domains
associated with their inputs and outputs.  The semirings in the 
GraphBLAS C API are defined with two domains associated with the input operands and one 
domain associated with output.  When used in the GraphBLAS C API these
domains may not match the domains of the matrices and vectors supplied in
the operations.  In this case, only valid \emph{domain compatible} casting 
is supported by the API.

The mathematical formalism for graph operations in the language of 
linear algebra often assumes that we can operate in the field of real numbers. 
However, the GraphBLAS C binding is designed for implementation on computers, 
which by necessity have a finite number of bits to represent numbers. 
Therefore, we require a conforming implementation to use floating point 
numbers such as those defined by the IEEE-754 standard (both single- and double-precision) 
wherever real numbers need to be represented. The practical implications of 
these finite precision numbers is that the result of a sequence of 
computations may vary from one execution to the next as the grouping of operands
(because of associativity) within the operations changes.  While techniques are known to 
reduce these effects, we do not require or even expect an implementation 
to use them as they may add considerable overhead. In most 
cases, these roundoff errors are not significant. When they are significant, 
the problem itself is ill-conditioned and needs to be reformulated.


\section{LAgraph  objects}

Objects defined in the GraphBLAS standard include types (the domains of 
elements), collections of elements (matrices, vectors, and scalars), operators 
on those elements (unary, index unary, and binary operators), algebraic 
structures (semirings and monoids), and descriptors.   GraphBLAS objects are 
defined as opaque types; that is, they are managed, manipulated, and accessed 
solely through the GraphBLAS application programming interface. This gives an 
implementation of the GraphBLAS C specification flexibility to optimize objects 
for different scenarios or to meet the needs of different hardware platforms.

A GraphBLAS opaque object is accessed through its \emph{handle}.  A handle is 
a variable that references an instance of one of the types from 
Table~\ref{Tab:ObjTypes}.  An implementation of the GraphBLAS specification 
has a great deal of flexibility in how these handles are implemented.  All 
that is required is that the handle corresponds to a type defined in the 
C language that supports assignment and comparison for equality.  The
GraphBLAS specification defines a literal {\sf GrB\_INVALID\_HANDLE} that is 
valid for each type.  Using the logical equality operator from C, it must be 
possible to compare a handle to {\sf GrB\_INVALID\_HANDLE} to verify that a 
handle is valid.


\begin{table}
\hrule
\begin{center}
\caption{Types of GraphBLAS opaque objects.}
\label{Tab:ObjTypes}
~\\
\begin{tabular}{l|l}
{\sf GrB\_Object types} & Description \\
\hline
{\sf GrB\_Type}           & Scalar type.     \\ \hline
{\sf GrB\_UnaryOp}        & Unary operator.     \\
{\sf GrB\_IndexUnaryOp}   & Unary operator, that operates on a single value and its location index values.     \\
{\sf GrB\_BinaryOp}       & Binary operator.     \\
{\sf GrB\_Monoid}         & Monoid algebraic structure.     \\
{\sf GrB\_Semiring}       & A GraphBLAS semiring algebraic structure. \\ \hline
{\sf GrB\_Scalar}         & One element; could be empty. \\ 
{\sf GrB\_Vector}         & One-dimensional collection of elements; can be sparse.     \\
{\sf GrB\_Matrix}         & Two-dimensional collection of elements; typically sparse.    \\ \hline
{\sf GrB\_Descriptor}     & Descriptor object, used to modify behavior of methods (specifically \\
                          & GraphBLAS operations).     \\
\end{tabular}
\end{center}
\hrule
\end{table}

Every GraphBLAS object has a \emph{lifetime}, which consists of
the sequence of instructions executed in program order between the
\emph{creation} and the \emph{destruction} of the object.  The GraphBLAS C
API predefines a number of these objects which are created
when the GraphBLAS context is initialized by a call to {\sf GrB\_init}
and are destroyed when the GraphBLAS context is terminated by a call to
{\sf GrB\_finalize}.

An application using the GraphBLAS API can create additional objects by
declaring variables of the appropriate type from Table~\ref{Tab:ObjTypes} for 
the objects it will use.  Before use, the object must be initialized 
with a call call to one of the object's respective \emph{constructor} methods.  
Each kind of object has at least one explicit constructor method of the form 
{\sf GrB\_*\_new} where `{\sf *}' is replaced with the type of object (e.g., 
{\sf GrB\_Semiring\_new}). Note that some objects, especially collections, 
have additional constructor methods such as duplication, import, or 
deserialization.  Objects explicitly created by a call to a constructor 
should be destroyed by a call to {\sf GrB\_free}. The behavior of a program
that calls {\sf GrB\_free} on a pre-defined object is undefined.

These constructor and destructor methods are the only methods that change 
the value of a handle.  Hence, objects changed by these methods are passed
into the method as pointers.  In all other cases, handles are not changed by the 
method and are passed by value.  For example, even when multiplying matrices, 
while the contents of the output product matrix changes, the handle for that 
matrix is unchanged. 

Several GraphBLAS constructor methods take other objects as input arguments
and use these objects to create a new object. For all these
methods, the lifetime of the created object must end strictly before
the lifetime of any dependent input objects. For example, a vector constructor
{\sf GrB\_Vector\_new} takes a {\sf GrB\_Type} object as input. That type
object must not be destroyed until after the created vector is destroyed.
Similarly, a {\sf GrB\_Semiring\_new} method takes a monoid and
a binary operator as inputs. Neither of these can be destroyed until
after the created semiring is destroyed.

Note that some constructor methods like {\sf GrB\_Vector\_dup} and 
{\sf GrB\_Matrix\_dup} behave differently. In these cases, the input 
vector or matrix can
be destroyed as soon as the call returns. However, the original type
object used to create the input vector or matrix cannot be destroyed
until after the vector or matrix created by {\sf GrB\_Vector\_dup} or
{\sf GrB\_Matrix\_dup} is destroyed.  This behavior must hold for any
chain of duplicating constructors.

Programmers using GraphBLAS handles must be careful to distinguish between a 
handle and the object manipulated through a handle.  For example, a program may 
declare two GraphBLAS objects of the same type, initialize one, and then assign 
it to the other variable.  That assignment, however, only assigns the handle to 
the variable.  It does not create a copy of that variable (to do that, one 
would need to use the appropriate duplication method).  If later the object is 
freed by calling {\sf GrB\_free} with the first variable, the object is 
destroyed and the second variable is left referencing an object that no longer 
exists (a so-called ``dangling handle'').

In addition to opaque objects manipulated through handles, the GraphBLAS C API 
defines an additional opaque object as an internal object; that is, the object 
is never exposed as a variable within an application.  This opaque object is 
the mask used to control which computed values can be stored in the output 
operand of a \emph{GraphBLAS operation}.  .

